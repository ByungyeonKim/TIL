## 특정 숫자의 중복 횟수를 계산하는 배열 함수

부스트캠프 웹﹒모바일 6기 자가 진단을 봤다. 자가 진단은 부스트캠프에 지원하기 전 본인의 기초 지식을 점검하고, 내가 과정에 참여 할만한 사람인지 스스로 판단해보는 것이다. 그 중 마지막 문제를 푸는데 어려움을 겪었다. 쉬워 보였는데 막상 풀어보니 굉장히 어려웠다..결국 구글링을 통해 풀긴 했지만 다시 한번 자료구조와 컴퓨팅적 사고의 중요성에 대해 깨닫게 되었다.

문제는 다음과 같았다.

<!-- https://blog.naver.com/boostcamp_official/221978031932 -->

### 함수 구현

- 자연수가 들어있는 배열 arr가 매개변수로 주어집니다. 배열 arr안의 숫자들 중에서 앞에 있는 숫자들부터 뒤에 중복되어 나타나는 숫자들 중복 횟수를 계산해서 배열로 return 하도록 solution 함수를 완성해주세요. 만약 중복되는 숫자가 없다면 배열에 -1을 채워서 return 하세요.

### 입출력 예

| arr                            | result    |
| ------------------------------ | --------- |
| #1 [1, 2, 3, 3, 3, 3, 4, 4]    | [4, 2]    |
| #2 [3, 2, 4, 4, 2, 5, 2, 5, 5] | [3, 2, 3] |
| #3 [3, 5, 7, 9, 1]             | [-1]      |

- #1 3은 4번, 4는 2번씩 나타나므로 [4, 2]를 반환합니다.
- #2 2가 3번, 4가 2번, 5가 3번씩 나타나므로 [3, 2, 3]을 반환합니다.
- #3 중복해서 나타나는 숫자는 없으므로 [-1]을 반환합니다.

### 코드

```js
const arr1 = [1, 2, 3, 3, 3, 3, 4, 4];
const arr2 = [3, 2, 4, 4, 2, 5, 2, 5, 5];
const arr3 = [3, 5, 7, 9, 1];

function solution(arr) {
  const map = arr.reduce((prev, curr) => {
    prev.set(curr, (prev.get(curr) || 0) + 1);
    return prev;
  }, new Map());

  result = [];
  for (let [key, val] of map) {
    if (val > 1) result.push(val);
  }
  if (result.length === 0) {
    return [-1];
  }
  return result;
}

console.log(solution(arr2));
```

## 이게 되네..

많은 시행착오를 겪고 결국 풀었다. 각 숫자의 반복 횟수를 가져오는 것에 대해 많이 난감했다. 중복 횟수나 중복을 제거하는 것이 아닌 각 숫자의 반복 횟수다.
어쨋든 객체형식으로 반환하는 것까지는 됐었다. arr1을 예로 들면 {1: 1, 2: 1, 3: 4, 4: 2}을 반환했다. 여기서 또 한번 막혔고 결국 맵을 이용해 풀게 되었다.
그래..이해는 했다 이해는 했지만 결국은 내가 풀었다는 느낌이 스스로 들지 않았고 찝찝한 기분이 들었다. 그대로 따라친건 아니지만 저 코드를 남에게 설명할 수 있을까? 그래서 관련 자료구조를 공부하기로 했다.

## Map!!

new Map()을 이용한 자료구조는 처음 사용해보았다. 알아보니 객체와 배열 이 두 자료구조만으론 부족해서 맵이 등장하게 되었고 [ES6](https://262.ecma-international.org/6.0/#sec-map-constructor)에 도입된 모던한 자료구조이다.

객체와 배열은 다음과 같은 특징을 갖고 있다.

- 객체 : 키가 있는 컬렉션을 저장함
- 배열 : 순서가 있는 컬렉션을 저장함

여기서 맵은 키가 있는 데이터를 저장한다는 점에서 객체와 유사하지만 맵은 키에 다양한 자료형을 허용하고 삽입 순서를 기억한다.

- new Map() : 맵을 만든다.
- map.set(key, value) : key를 이용해 value를 저장한다.
- map.get(key) : key에 해당하는 값을 반환. key가 존재하지 않을 경우 undefined를 반환한다.
- map을 사용할땐 전용 메서드 set, get 등의 사용을 요구한다. (map[key] = 1 ❌)

```js
const map = new Map();

map.set('1', 'string key');
map.set(1, 'number key');
map.set(true, 'boolean key');

// 객체의 키는 반드시 String or Symbol이어야 한다.
// 맵은 키의 타입을 그대로 유지한다.
console.log(map.get(1)); // number key
console.log(map.get('1')); // string key
console.log(map.get(true)); // boolean key
```

## 맵의 요소에 반복 작업하기

바로 이 특징 덕분에 문제를 풀 수 있었다. 맵 자료구조는 배열처럼 반복 작업이 가능하다. `for..of`와 `forEach`를 지원한다! 객체와 배열의 특징을 둘 다 갖고 있기때문에 특정 숫자의 중복 횟수를 풀 수 있었다.

```js
result = [];
// {1 => 1, 2 => 1, 3 => 4, 4 => 2}
for (let [key, val] of map) {
  // 값이 1이상인 것만 빈 배열에 push
  if (val > 1) result.push(val);
}
```
