// 메모이제이션을 적용할 때 도움이 되는 네 가지 경우
// 1. 비싼 함수 호출, 즉 무거운 계산을 수행하는 함수
// 2. 반복 입력 값이 있는 재귀 함수
// 3. 순수함수, 즉 특정 입력으로 호출 될 때마다 동일한 출력을 반환하는 함수
// 4. 캐시된 값이 제한적이고 매우 반복적인 입력 범위를 가진 함수

// 이 중 재귀 함수의 경우(피보나치 수열)
// f₀ = 1, f₁ = 1, f𝑛 = f𝑛-₁ + f𝑛-₂(𝑛 ≥ 2)

// 반복되는(중복되는) 값이 있는 재귀 함수
function f(n) {
  if (n <= 1) return 1;
  return f(n - 1) + f(n - 2);
}

// 메모이제이션을 적용할 경우
let memo = [];
function f(n) {
  if (n <= 1) return 1;
  // 이미 계산된 값이 있다면 그 값을 반환
  if (memo[n]) return memo[n];
  return (memo[n] = f(n - 1) + f(n - 2));
}

// 불필요한 계산을 줄이는 것만 해도 성능 차이가 상당했다.
// f(100)을 재귀 함수로만 수행했을 경우 노트북이 뜨거워 지고 3분 이상 값을 반환하지 못했음.
